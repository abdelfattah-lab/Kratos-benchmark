from structure.exp import Experiment, ExperimentFactory
from structure.arch import ArchFactory
from structure.design import Design

from rich.progress import track
from rich.style import Style
from typing import Type, TypeVar
from concurrent.futures import ThreadPoolExecutor, as_completed

E = TypeVar('E', bound=Experiment)
class Runner():
    """
    Runs a list of Experiments as generated by an ExperimentFactory.
    """
    def __init__(self, arch: ArchFactory, design: Design, experiment_class: Type[E], params: dict[str, any]):
        """
        Generate all experiments.
        """
        self.factory = ExperimentFactory(arch, design, experiment_class)
        self.experiments = self.factory.gen_experiments(params)

    def run_all_threaded(self, desc='run', num_parallel_tasks=1, **kwargs) -> list[dict, dict]:
        """
        Main function: run all generated experiments with a thread pool.

        Optional arguments:
        * desc:str, description of run (displayed with the progress bar)
        * num_parallel_tasks:int, maximum number of simultaneous threads allowed in the thread pool.

        All other keyword arguments are passed directly to the Experiment.run() function.

        @return a list of (params, results).
        """
        # runnable
        def run_experiment(exp: Experiment) -> dict:
            exp.run(**kwargs)
            exp.wait()
            return exp.full_params, exp.get_result()
        
        # submit all Experiments into the ThreadPoolExecutor
        futures = []
        executor = ThreadPoolExecutor(max_workers=num_parallel_tasks)
        for exp in self.experiments:
            future = executor.submit(run_experiment, exp)
            futures.append(future)

        # collect all results
        results = []
        for future in track(as_completed(futures), description=desc, finished_style=Style(color='green'), total=len(futures)):
            results.append(future.result())
        
        executor.shutdown()
        return results